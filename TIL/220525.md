# 220525


### 병행 제어 ###

```
다중 사용자 환경에서 둘 이상의 트랜잭션이 동시에 접속하여 해당 연산을 수행할 때, 
문제점이 전혀 발생하지 않도록 트랜잭션의 수행을 적절히 제어해 주는 것
ex) 은행 업무에서 예금 입출금, 대출업무, 외환, 인터넷 뱅킹, 예금 해지 등의 많은 트랜잭션들이 동시에 수행하겠다고 접근하면 
DBMS는 데이터베이스의 공용도는 높이고, 응답 시간은 최소화하며, 시스템 활용도는 증대시킬 수 있는 방안으로 병행 제어를 수행한다.

그러나 동시에 동일한 내용을 접근하거나 변경하려는 경우에는 트랜잭션 단위로 처리하게 된다.
만약, 이 상황에서 병행 수행 제얼르 하지 않는다면, 부정확한 데이터가 만들어질 수 있다. 
```

<br>

__1. 무제어 병행 수행의 문제점__
- __갱신 분실__ : 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화 됨
- __모순성__ : 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고, 또 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황
- __연쇄 복귀__ : 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생하며, 한 트랜잭션이 데이터를 갱신한 다음 실패하여 rollback 연산을 수행하는 과정에서, 갱신과 rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제. 즉, 실패한 트랜잭션이 갱신한 값을 원래의 값으로 되돌리기 전에 다른 트랜잭션이 그 값을 읽게 되는 상태

<br>

__2. 트랜잭션 스케줄__
- 데이터 베이스 트랜잭션을 구성하는 연산들의 실행 순서를 의미하는 것.   
 다중 프로그래밍 환경에서 인터리빙 방식으로 여러 개의 트랜잭션을 처리하기 위해서는 트랜잭션에 포함된 각각의 연산들에 대한 실행 순서를 지정하는 것이 매우 중요하다.
 - __직렬 스케줄(serial schedule)__ : 트랜잭션의 연산을 모두 순차적으로 실행하는 유형, 인터리빙 방식으로 처리되지 않기 때문에, 다중 프로그래밍 환경에서는 CPU의 활용도가 떨어짐. 트랜잭션의 수행 순서의 경우의 수는 n!이 존재한다.
 - __비직렬 스케줄(nonserial schedule)__ : 트랜잭션 직렬 수행 순서와 상관없이 병행 수행하는 스케줄을 의미, 인터리빙 방식으로 처리된다. 
 - __직렬 가능 스케줄(serializable scheule)__ : 직렬스케줄과 동등한 비직렬 스케줄. 동시에 수행되는 트랜잭션간의 상호 간섭이 배제되어야 하며, 이를 위해서 read 연산과 write 연산의 순서가 중요
 
 <br>
 
 __3. 병행 제어 기법__
- __로킹(locking) 기법__
	- 여러 트랜잭션들이 동일한 데이터 항목에 대해 임의적인 병행 접근을 하지 못하도록 제어   
	- lock과 unlock 두 가지 연산을 사용 > 트랜잭션이 사용하려고 하는 데이터 항목에 대해 상호 배제를 적용함으로써 직렬 가능 스케줄 실현   
	- __로킹 연산의 종류__
		- __공용 로크(shared-lock)__ : 트랜잭션T는 해당 데이터 x에 대해서 읽을 수는 있지만 기록할 수는 없다, 다른 트랜잭션은 x에 대해서 shared-lock을 동시에 설정할 수 있다.
		- __전용 로크(exclusive-lock)__ : 트랜잭션T는 해당 데이터 x에 대해서 읽을 수도 있고, 기록할 수도 있다, 다른 트랜잭션은 x에 대해서 어떠한 lock도 설정할 수 없다.
	- __로킹 단위__
		- 로킹 기법에서 사용하는 lock 연산의 대상, 즉 병행 수행 제어의 데이터 단위 > 전체 데이터베이스부터 최소 단위인 속성까지 다양   
		- 로킹 단위가 극단적으로 데이터베이스가 된다면 병행성은 전혀 없게 되고(직렬 스케줄과 동등한 상태), 반대로 로킹의 단위가 속성이 되면 최대의 병해성을 제공받을 수 있음   
		- 로킹 단위의  결정은 로킹 기법의 성능을 좌우하는 중요한 문제
	- __2단계 로킹 규약__(2PLP: two-phase locking protocol)
		- 직렬 가능성을 보장받을 수 있는 규약으로 가장 많이 사용됨
		1. 확장단계(growing phase) : 트랜잭션은 새로운 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계
		2. 축소 단계(shrinking phase) : 트랜잭션은 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계
	- __교착상태(daedlock)__
		- 둘 이상의 트랜잭션이 서로 상대가 가지고 있는 데이터 항목의 로크가 해제되기만을 기다림으로써 트랜잭션 실행이 중단되고, 무한정 기다리는 상태
		- 해결방법
			1. 회피(avoidance): 타임스탬프 순서 기법 이용
			2. 예방(prevention) : 트랜잭션을 실행시키기 전에 교착상태 발생을 불가능하게 만드는 방법
			3. 탐지(detection) : 교착상태가 일단 일어난 뒤에 교착상태를 발생시킨 트랜잭션 하나를 제거하는 것   
			
			<br>
			
- __타임스탬프 순서(timestamp ordering) 기법__
	- 시스템에서 생성하는 고유 번호인 타임스탬프를 트랜잭션에 부여하여 실행 > 직렬스케줄과 결과가 항상 같도록 보장
	- 타임스탬프 생성 방법
		1. 논리적 계수기(logical counter) : 트랜잭션이 시스템에 들어올 때마다 숫자를 하나씩 증가시켜 트랜잭션의 타임스탬프 값을 부여하는 것
		2. 시스템 클록(system clock) : 트랜잭션이 시스템에 들어오면 시스템 클록의 값을 그 트랜잭션의 타임스탬프 값으로 부여
	- 타임스탬프 값
		1. read_TS(x) : 데이터 항목 x의 판독 타임스탬프로서, read(x)를 성공적으로 실행한 트랜잭션의 타임스탬프 중에서 제일 큰 값
		2. write_TS(x) : 데이터 항목 x의 기록 타임스탬프로서, write(x)를 성공적으로 실행한 트랜잭션의 타임스탬프 중에서 제일 큰 값