# 220523


### 데이터 베이스 설계 ###   
```
현실 세계 > 개념 세계 > 컴퓨터 세계
              ㄴ (DB에 저장될 테이블, 뷰 등의 구조로 디자인하고 기본키, 외래키, 인덱스 등의 요소들을 계획)
```   
<BR>
  
__1. 데이터베이스 생명주기__
- __요구 조건 분석__ : 업무, 시스템 운영상태, 사용자 요구사항 분석
-	__설계__ : 프로세스 중심 설계=애플리케이션, 데이터 중심 설계=데이터베이스
-	__구현__ : 특정 DBMS 제품에 대하여 그 환경에 맞도록 구현, 데이터베이스 구축
-	__운영__ : 데이터베이스를 실제로 운영하기 위해 여러가지 조작 및 관리
-	__감시 및 개선__ : 새로운 요구 조건에 대처, 성능 개선 <- 계속적으로 감시   

<br>
  
__2. 데이터베이스 설계 5단계__   
1.	__요구 조건 분석__ : 요구 조건 명세서 작성
2.	__개념적 설계__ : 개념 스키마, 트랜잭션 모델링, e-r 모델(dbms에 독립적이고 고차원적)
3.	__논리적 설계__ : 목표 dbms에 맞는 스키마 설계 (트랜잭션 인터페이스 설계, 정규화)
4.	__물리적 설계__ : 목표 dbms에 맞는 물리적 구조의 데이터로 변환
5.	__구현__ : 특정 dbms의 ddl로 데이터베이스 생성   

<br>
  
__3. 개념적 설계__   
- __ERD IE 방식 관계 표현 방법__
  - 일대일 : 필수 <s>ㅣ     　 　    Oㅣ</s> 선택
  - 일대다 : 필수 <s>ㅣ     　　    Oㅣ<</s> 선택   
- __엔티티 도출__ : 명사
-	__주 식별자 정의__ : 엔티티에 소속된 인스턴스들을 구분한느 기준이 되는 속성, 물리적 데이터베이스에서는 튜플을 구분하는 기본키
-	__관계의 정의__ : 일반적으로 부모 자식 간의 관계가 존재함
-	__외래식별자의 정의__ : 관계가 잇는 두 엔티티를 부모,자식으로 구분하고 부모 엔티티의 주 식별자 속성을 자식이 가지고 잇는지를 확인한다(없을 경우 추가)
-	__식별 관계__ : 부모 테이블의 기본키가 자식 테이블의 기본키 혹은 후보키 그룹의 구성원으로 전이되는 관계 
-	__비식별 관계__ : 부모테이블의 기본키가 자식 테이블의 일반 칼럼으로 전이되는 관계    
  
<br>
  
__4. 논리적 설계__
```
ER스키마를 관계 데이터 모델의 릴레이션으로 사상해야 한다. 
엔티티 타입과 관계 타입이 존재하지만 관계 데이터 모델에는 엔티티 타입과 관계 타입을 구분하지 않고 릴레이션들만 존재하기 때문이다.
ERD는 다대다(N:M)의 관계와 다중 값 속성까지 허용하지만 우리가 구현하는 관계형 데이터베이스는 N:M 관계를 허용하지 않고 
하나의 속성에 오직 하나의 값만을 허용하기 때문에 이 부분을 만족하도록 모델링르 재조정해야 한다.(정규화)
```

<br>

__5. 물리적 설계__
-	__고려사항__ : 응답 시간의 최소화, 저장 공간의 효율화, 트랜잭션 처리도(처리 능력)
-	__자료 검색 방법__
    -	FTS(Full Table Scan) : 테이블을 처음부터 끝까지 검색하는 방법. 중간에 원하는 정보를 모두 검색했다고 할지라도 테이블을 끝까지 검색한다.
    -	인덱스 스캔 : 원하는 정보를 인덱스를 통해 부분 검색을 하여 인덱스에 저장된 테이블의 rowid를 가지고 테이블을 검색한 후 정보를 가져오는 검색 방법. 이때 인덱스는 기본적으로 정렬 되어 있으므로, 부분 검색으로 검색이 가능하다. 또한, 검색된 정보는 인ㄷ덱스 컬럼으로 정렬되어 보인다.
-	__인덱스 종류__
    - 논리적 구분에 따른 인덱스 : 단일 칼럼 인덱스와 결합 인덱스 , Unique 인덱스와 Non-Unique 인덱스, 함수기반 인덱스
    -	물리적 구분에 따른 인덱스 : B-tree 구조 인덱스, 비트맵 인덱스, 클러스터링 인덱스
-	__성능 향상을 위한 인덱스 관리__
   -	인덱스 정보 확인
   -	인덱스 재구축(ALTER INDEX idx_ename_emp REBUILD TABLESPACE indx02;
    -	인덱스 삭제(DROP INDEX idx_ename_emp; )
-	__역정규화__ : 시스템 성능을 고려해서 기존 설계를 재구성 하는 것   
(지나친 정규화는 릴레이션을 최소 단위로 분해시키게 되는데, 이렇게 분해된 릴레이션들에서 데이터를 추출하려면 정규화가 이루어진 만큼의 여러 테이블을 조인해야 원하는 데이터를 얻을 수 있게 되기 때문이다. 여러 테이블을 조인하는 경우 SQL문이 복잡할 뿐만 아니라 시스템 성능도 크게 저하된다.)
    -	칼럼 역정규화 : 테이블 간의 조인을 줄이고자 데이터의 중복 허용
    -	테이블 분리 : (한 칼럼의 데이터 크기가 너무 큰 경우) 테이블 하나를 여러 테이블로 분리 > 칼럼에 대한 불필요한 검색이 이루어지지 않도록 함 
    -	테이블 통합 : 정규화를 통해서 나눈 테이블을 다시 하나의 테이블로 통합.   
  (역정규화는 테이블 하나에 특정 칼럼들만 추가했다면 테이블 통합은 두 테이블의 모든 칼럼을 하나의 테이블로 만드는작업)
    -	요약 테이블 생성 : 논리적 결합 작업으로 시스템의 성능이 저하되는 단점을 개선하려고 생성. 
-	__데이터베이스 용량 설계__ : 데이터가 저장되는 공간을 정의하는 작업
    -	목적 : 디스크 사용의 효율을 최대화, 업무량이 집중되어 있는 디스크를 분리하여 설계함으로써 집중화된 디스크의 입출력 부하를 분산, 디스크 입출력 로드를 최소화, 데이터베이스 오브젝트의 추가적인 스페이스 확장작업 발생 최소화
    -	분석 절차 : 기초 데이터 수집 > DBMS에 이용하는 오브젝트별 용량 산정(테이블 크기, 인덱스 크기 등) > 테이블 스페이스 용량 산정(dbms에 적합하게 계산하여 산출하고 이를 더한 값에다가 테이블이 추가적으로 확장되는 것을 고려하여 대략 40% 정도의 스페이스를 더 확보하여 산정) > 디스크 용량 선정
  

  <BR>
  
  __6. 테이블 정의서 및 ERD 작성__
![image](https://user-images.githubusercontent.com/94505794/169736667-f9b1d653-a950-43c6-88b7-0633689cd4ee.png)

<br><br>

### 트랜잭션 ###

```
- 하나의 그룹으로 처리해야하는 명령문들을 모아 놓는 작업 단위.   
- 예를 들어 4개의 SQL 문장이 하나의 그룹으로 묶인 작업 단위인 경우, 
　4개의 SQL 문장이 완전히 처리되거나 아니면 하나도 처리되지 않아야하는 All-OR-Nothing 방식으로 처리   
 
- 트랜잭션 내의 모든 처리대상 명령문들이 반드시 완전히 수행되어야 하며,
　만약 모두가 완전히 수행되지 않고 어느 한 문장이라도 에러가 발생하였다면 트랜잭션으로 묶인 전체 명령문은 모두 취소가 되게 된다.
```

<br>

__1. 특징__   
```데이터 무결성을 지키기 위한 방법으로 데이터베이스 시스템은 트랜잭션의 4가지 특징을 지원하고 있으며, 이를 모두 만족해야 한다.```
-	__원자성(Atomicity)__ : 트랜잭션의 수행은 원자적이다(All-OR-Nothing 방식)
-	__일관성(Consistency)__ : 트랜잭션 실행을 성공적으로 완료하면, 언제나 일관성 있는 데이터베이스 상태로 유지되어야 한다.(실행 중에는 일관성 유지 될 필요 없음)
-	__격리성(Isolation : 고립성)__ : 트랜잭션들이 서로 독립성을 보장받으며 수행
- __영속성(Durability : 지속성)__ : 트랜잭션이 모든 작업을 성공적으로 수행 완료하여 데이터베이스 내에 반영했다면, 트랜잭션의 결과는 영구적이어야 함

<br>

__2. 트랜잭션 연산__
-	__COMMIT 연산(완료/성공적인 종료)__ : 하나의 트랜잭션에 대한 작업이 성공적으로 종료하고, 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 연산이 완료된 것을 COMMIT 문장을 통해 트랜잭션 관리자에게 알려 주는 연산이다.
-	__ROLLBACK 연산(복귀/ 비정상적인 종료)__ : 해당 트랜잭션이 행한 모든 연산을 취소시키거나 트랜잭션을 재시작하도록 한다.

<br>

__3. 트랜잭션의 상태__
-	__활동(active)__ : 실행을 시작하였거나 현재 실행 중인 상태, ‘부분 완료’나 ‘실패’상태로 전이
-	__부분 완료(partially committed)__ : 트랜잭션이 마지막 명령문을 실행시킨 직후의 상태, ‘실패’나 ‘완료’상태로 전이
- __실패(failed)__ : 트랜잭션 실행 중 장애나 오류가 발생하여 정상적인 실행을 더 이상 할 수 없는 상태, ‘철회’ 상태로 전이
-	__철회(aborted)__ : 실행에 실패하여 rollback 연산을 수행한 상태, 트랜잭션이 일부 실행되어 반영된 데이터베이스 내의 모든 변경을 반드시 취소해야 한다.
    - 트랜잭션 재시작 : 철회 원인이 트랜잭션 자체적인 논리적 오류가 아닌 하드웨어나 소프트웨어 오류로 인행 중단된 경우에 사용
    - 트랜잭션 강제 종료 : 트랜잭션 철회 원인이 트랜잭션 내부적으로 논리적 오류가 발생하여 오류를 수정해야만 하는 상황이거나 또는 얻고자 하는 데이터가 데이터베이스 내에 존재하지 않는 경우에 
-	__완료(committed)__ : 트랜잭션 실행이 성공적으로 완료되어 commit연산을 수행한 상태, 트랜잭션을 통해 변경된 내용이 데이터베이스 내에 안전하게 저장되며, 영속성을 보장받음

<br>

__4. A계좌에서 B계좌로 2000을 이체하는 트랜잭션__
```sql
ACCOUNT_TRANS:						//트랜잭션 이름
	Begin_transaction				//트랜잭션의 시작으로 "활동" 상태 유지
	{
		SELECT
			acct_amt INTO : tmp_ampt		
		FROM
			ACCT_SAVE
		WHERE
			acct_name = 'A';		// A 계좌에서 잔액을 조회하여 임시변수 tmp_amp에 저장
		                                      //A계좌에서 B계좌로 2000을 이체하기 위한 잔액 비교 루틴
		IF tmp_amt < 2000 then			// tmp_amt 내에 값을 비교하여 잔액이 부족하면,
		{
			printf("잔액이 부족합니다.");	// 메세지로 결과를 알린 후
			GO TO EPR_RTN;			// 더 이상 진행하지 않고, ERR_RTN 루틴 실행
			                                  //트랜잭션 상태 "실패"이며, "철회"로 이동 예정
		}ELSE {					// 잔액이 부족하지 않으면, 계좌 이체 루틴 실행
			UPDATE ACCT_SAVE
			SET acct_amt = acct_amt - 2000
			WHERE acct_name = 'A';

			
			IF ERROR then GO TO ERR_RTN;        //문장을 수행하다가 문제가 발생하면, ERR_RTN 루틴 실행
		                                         //트랜잭션 상태 "실패"이며, "철회"로 이동 예정
      
			UPDATE ACCT_SAVE
			SET acct_amt = acct_amt + 2000
			WHERE acct_name = 'B';

			
			IF ERROR then GO TO ERR_RTN;  //마지막 명령문 수행 직후 트랜잭션 상태 "부분완료" 문장을 수행하다가
			                             // 문제가 발생하면, ERR_RTN 루틴 실행 트랜잭션 상태 "실패"이며, "철회"로 이동 예정

			COMMIT;				//정상적으로 문장이 수행되어 commit문수행 "완료"
			printf("계좌이체가 정상적으로 수행 되었습니다);
			GO TO END_RTN;
		}
		ERR_RTN;
		ROLLBACK;				//문장 수행을 실패하여 ROLLBACK문 수행 "철회"

		END_RTN;
		RETURN;
	}
	End_transaction
```      